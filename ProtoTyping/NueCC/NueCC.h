////////////////////////////////////////////////////////////////////////
// Class:       NueCC
// Plugin Type: analyzer (art v2_11_03)
// File:        NueCC_module.cc
//
// Generated by Wouter Van de pontseele using cetskelgen
////////////////////////////////////////////////////////////////////////

#ifndef NUECC_H
#define NUECC_H

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "lardataobj/RecoBase/PFParticle.h"
#include "lardataobj/RecoBase/Vertex.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/RecoBase/Shower.h"
#include "lardataobj/RecoBase/Cluster.h"
#include "lardataobj/RecoBase/SpacePoint.h"
#include "lardataobj/RecoBase/PFParticleMetadata.h"

#include "nusimdata/SimulationBase/MCParticle.h"
#include "nusimdata/SimulationBase/MCTruth.h"

#include "larpandora/LArPandoraInterface/LArPandoraHelper.h"

#include "helpers/PandoraInterfaceHelper.h"

#include "TTree.h"

class NueCC;

class NueCC : public art::EDAnalyzer
{
  public:
    explicit NueCC(fhicl::ParameterSet const &p);
    // The compiler-generated destructor is fine for non-base
    // classes without bare pointers or other resource use.

    // Plugins should not be copied or assigned.
    NueCC(NueCC const &) = delete;
    NueCC(NueCC &&) = delete;
    NueCC &operator=(NueCC const &) = delete;
    NueCC &operator=(NueCC &&) = delete;

    // Required functions.
    void analyze(art::Event const &e) override;
    void reconfigure(fhicl::ParameterSet const &p);
    void clearEvent();
    void clearDaughter();

    /**
     *  @brief  Collect and fill the reconstructed information.
     *
     *  @param  e Art event
     */
    void FillReconstructed(art::Event const &e);

    /**
     *  @brief  Collect and fill the MC based information.
     *
     *  @param  e Art event
     */
    void FillTruth(art::Event const &e);

    /**
     *  @brief  Fill the tree for every daughter of the neutrino candidate.
     *
     *  @param  pfparticle ptr The Pfparticle corresponding to the daughter.
     *  @return 1 if succesful, 0 if failure.
     */
    bool FillDaughters(const art::Ptr<recob::PFParticle> &pfp);

  private:
    // Fields needed for the analyser
    std::string m_pfp_producer;
    std::string m_hitfinder_producer;
    std::string m_geant_producer;
    std::string m_hit_mcp_producer;
    bool m_hasMCNeutrino;
    bool m_isData;

    PandoraInterfaceHelper pandoraInterfaceHelper;

    // LAr Pandora Helper fields
    lar_pandora::LArPandoraHelper larpandora;
    lar_pandora::PFParticleVector pfparticles;
    lar_pandora::PFParticleVector pfneutrinos;
    lar_pandora::PFParticleVector pfdaughters;
    lar_pandora::PFParticleMap particleMap;
    lar_pandora::PFParticlesToMetadata particlesToMetadata;
    lar_pandora::PFParticlesToVertices particlesToVertices;
    lar_pandora::PFParticlesToClusters particlesToClusters;
    lar_pandora::PFParticlesToSpacePoints particlesToSpacePoints;
    lar_pandora::ClustersToHits clustersToHits;
    lar_pandora::HitsToSpacePoints hitsToSpacePoints;
    lar_pandora::SpacePointsToHits spacePointsToHits;
    // Used for reco truth matching
    lar_pandora::PFParticlesToMCParticles matchedParticles;
    std::set<art::Ptr<simb::MCParticle>> matchedMCParticles;

    //// Tree for every event
    TTree *fEventTree;
    uint fRun, fSubrun, fEvent;
    // MC neutrino info
    uint fNumNu; // number of MC neutrinos in event, only one gets saved!
    int fTrueNu_InteractionType;
    int fTrueNu_CCNC;
    int fTrueNu_PDG;
    float fTrueNu_Energy;
    float fTrueNu_LeptonEnergy;
    float fTrueNu_Time; // time of the true neutrino interaction
    float fTrueNu_Vx, fTrueNu_Vy, fTrueNu_Vz;
    float fTrueNu_VxSce, fTrueNu_VySce, fTrueNu_VzSce;
    // Reco candidate info
    float fNu_PDG;
    float fNu_Score;
    uint fNu_SliceIndex;
    float fNu_Vx, fNu_Vy, fNu_Vz;
    uint fNu_NhitsU, fNu_NhitsV, fNu_NhitsY;
    uint fNu_NhitsSpacepoints;
    uint fNumPrimaryDaughters;
    uint fNumDaughters;
    uint fNumShowers;
    uint fNumTracks;
    bool fDaughtersStored; // if all the neutrino daughters were stored correctly

    //// Tree for every daughter
    TTree *fNueDaughtersTree;
    // Reco candidate info
    uint fGeneration;
    float fTrackScore;
    bool fIsTrack;  // if the pfparticle was associated with a track
    bool fIsShower; // if the pfparticle was associated with a shower
    bool fHasShowerDaughter;
    bool fIsTrackDaughter;
    float fVx, fVy, fVz;
    uint fNhitsU, fNhitsV, fNhitsY;
    uint fNhitsSpacepoints;
    // Matched MCParticle info
    int fTruePDG;
    float fTrueEnergy;
    float fTrueVx, fTrueVy, fTrueVz;
    float fTrueVxSce, fTrueVySce, fTrueVzSce;
};

void NueCC::reconfigure(fhicl::ParameterSet const &p)
{
    m_pfp_producer = p.get<std::string>("pfp_producer", "pandoraConsolidated");
    m_hitfinder_producer = p.get<std::string>("hitfinder_producer", "gaushit");
    m_geant_producer = p.get<std::string>("geant_producer", "largeant");
    m_hit_mcp_producer = p.get<std::string>("hit_mcp_producer", "gaushitTruthMatch");

    m_isData = p.get<bool>("is_data", false);
    m_hasMCNeutrino = p.get<bool>("has_MC_neutrino", false);
}

NueCC::NueCC(fhicl::ParameterSet const &p)
    : EDAnalyzer(p)
{
    art::ServiceHandle<art::TFileService> tfs;
    this->reconfigure(p);

    //// Check if things are set up properly:
    std::cout << std::endl;
    std::cout << "[NueCC constructor] Checking set-up" << std::endl;
    std::cout << "[NueCC constructor] pfp_producer: " << m_pfp_producer << std::endl;
    std::cout << "[NueCC constructor] is_data: " << m_isData << std::endl;
    std::cout << "[NueCC constructor] has_MC_neutrino: " << m_hasMCNeutrino << std::endl;

    //// Tree for every event
    fEventTree = tfs->make<TTree>("Event", "Event Tree");
    fEventTree->Branch("event", &fEvent, "event/i");
    fEventTree->Branch("run", &fRun, "run/i");
    fEventTree->Branch("subrun", &fSubrun, "subrun/i");
    fEventTree->Branch("hitsU", &fNu_NhitsU, "hitsU/i");
    fEventTree->Branch("hitsV", &fNu_NhitsV, "hitsV/i");
    fEventTree->Branch("hitsY", &fNu_NhitsY, "hitsY/i");
    fEventTree->Branch("hitsSps", &fNu_NhitsSpacepoints, "hitsSps/i");
    fEventTree->Branch("num_primary_daughters", &fNumPrimaryDaughters, "num_primary_daughters/i");
    fEventTree->Branch("num_daughters", &fNumDaughters, "num_daughters/i");
    fEventTree->Branch("num_showers", &fNumShowers, "num_showers/i");
    fEventTree->Branch("num_tracks", &fNumTracks, "num_tracks/i");
    fEventTree->Branch("daughters_stored", &fDaughtersStored, "daughters_stored/O");
    fEventTree->Branch("nu_vx", &fNu_Vx, "nu_vx/F");
    fEventTree->Branch("nu_vy", &fNu_Vy, "nu_vy/F");
    fEventTree->Branch("nu_vz", &fNu_Vz, "nu_vz/F");
    fEventTree->Branch("nu_pdg", &fNu_PDG, "nu_pdg/I");
    if (m_hasMCNeutrino && !m_isData)
    {
        fEventTree->Branch("num_neutrinos", &fNumNu, "num_neutrinos/i");
        fEventTree->Branch("mc_nu_vx", &fTrueNu_Vx, "mc_nu_vx/F");
        fEventTree->Branch("mc_nu_vy", &fTrueNu_Vy, "mc_nu_vy/F");
        fEventTree->Branch("mc_nu_vz", &fTrueNu_Vz, "mc_nu_vz/F");
        fEventTree->Branch("mc_nu_vx_sce", &fTrueNu_VxSce, "mc_nu_vx_sce/F");
        fEventTree->Branch("mc_nu_vy_sce", &fTrueNu_VySce, "mc_nu_vy_sce/F");
        fEventTree->Branch("mc_nu_vz_sce", &fTrueNu_VzSce, "mc_nu_vz_sce/F");
        fEventTree->Branch("mc_nu_energy", &fTrueNu_Energy, "mc_nu_energy/F");
        fEventTree->Branch("mc_nu_lepton_energy", &fTrueNu_LeptonEnergy, "mc_nu_lepton_energy/F");
        fEventTree->Branch("mc_nu_time", &fTrueNu_Time, "mc_nu_time/F");
        fEventTree->Branch("mc_nu_pdg", &fTrueNu_PDG, "mc_nu_pdg/I");
        fEventTree->Branch("mc_nu_interaction_type", &fTrueNu_InteractionType, "mc_nu_interaction_type/I");
        fEventTree->Branch("mc_nu_ccnc", &fTrueNu_CCNC, "mc_nu_ccnc/O");
    }

    //// Tree for every daughter
    fNueDaughtersTree = tfs->make<TTree>("Daughters", "Daughters Tree");
    fNueDaughtersTree->Branch("event", &fEvent, "event/i");
    fNueDaughtersTree->Branch("run", &fRun, "run/i");
    fNueDaughtersTree->Branch("subrun", &fSubrun, "subrun/i");
    fNueDaughtersTree->Branch("hitsU", &fNhitsU, "hitsU/i");
    fNueDaughtersTree->Branch("hitsV", &fNhitsV, "hitsV/i");
    fNueDaughtersTree->Branch("hitsY", &fNhitsY, "hitsY/i");
    fNueDaughtersTree->Branch("hitsSps", &fNhitsSpacepoints, "hitsSps/i");
    fNueDaughtersTree->Branch("generation", &fGeneration, "generation/i");
    fNueDaughtersTree->Branch("track_score", &fTrackScore, "track_score/F");
    fNueDaughtersTree->Branch("is_shower", &fIsShower, "is_shower/O");
    fNueDaughtersTree->Branch("is_track", &fIsTrack, "is_track/O");
    fNueDaughtersTree->Branch("has_shower_daughter", &fHasShowerDaughter, "has_shower_daughter/O");
    fNueDaughtersTree->Branch("is_track_daughter", &fIsTrackDaughter, "is_track_daughter/O");
    fNueDaughtersTree->Branch("vx", &fVx, "vx/F");
    fNueDaughtersTree->Branch("vy", &fVy, "vy/F");
    fNueDaughtersTree->Branch("vz", &fVz, "vz/F");

    if (m_hasMCNeutrino && !m_isData)
    {
        fNueDaughtersTree->Branch("mc_vx", &fTrueVx, "mc_vx/F");
        fNueDaughtersTree->Branch("mc_vy", &fTrueVy, "mc_vy/F");
        fNueDaughtersTree->Branch("mc_vz", &fTrueVz, "mc_vz/F");
        fNueDaughtersTree->Branch("mc_vx_sce", &fTrueVxSce, "mc_vx_sce/F");
        fNueDaughtersTree->Branch("mc_vy_sce", &fTrueVySce, "mc_vy_sce/F");
        fNueDaughtersTree->Branch("mc_vz_sce", &fTrueVzSce, "mc_vz_sce/F");
        fNueDaughtersTree->Branch("mc_energy", &fTrueEnergy, "mc_energy/F");
        fNueDaughtersTree->Branch("mc_pdg", &fTrueNu_PDG, "mc_pdg/I");
    }
}

void NueCC::clearEvent()
{
    fNu_PDG = 0; // if 0, no neutrinocandidate was found, only look at truth information.
    fDaughtersStored = true;
    fNumShowers = 0;
    fNumTracks = 0;
    fNu_NhitsU = 0;
    fNu_NhitsV = 0;
    fNu_NhitsY = 0;
    fNu_NhitsSpacepoints = 0;

    pfparticles.clear();
    pfneutrinos.clear();
    pfdaughters.clear();
    particleMap.clear();
    particlesToMetadata.clear();
    particlesToVertices.clear();
    particlesToClusters.clear();
    particlesToSpacePoints.clear();
    clustersToHits.clear();
    hitsToSpacePoints.clear();
    spacePointsToHits.clear();
}

void NueCC::clearDaughter()
{
    fIsShower = false;
    fIsTrack = false;
    fHasShowerDaughter = false;
    fIsTrackDaughter = false;

    fNhitsU = 0;
    fNhitsV = 0;
    fNhitsY = 0;
    fNhitsSpacepoints = 0;
}

DEFINE_ART_MODULE(NueCC)
#endif // NUECC_H